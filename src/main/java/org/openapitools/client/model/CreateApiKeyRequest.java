/*
 * Amazon API Gateway
 * <fullname>Amazon API Gateway</fullname> <p>Amazon API Gateway helps developers deliver robust, secure, and scalable mobile and web application back ends. API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.</p>
 *
 * The version of the OpenAPI document: 2015-07-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.StageKey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateApiKeyRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T13:10:54.869209+05:30[Asia/Kolkata]", comments = "Generator version: 7.10.0")
public class CreateApiKeyRequest {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nullable
  private String name;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  @javax.annotation.Nullable
  private String description;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  @javax.annotation.Nullable
  private Boolean enabled;

  public static final String SERIALIZED_NAME_GENERATE_DISTINCT_ID = "generateDistinctId";
  @SerializedName(SERIALIZED_NAME_GENERATE_DISTINCT_ID)
  @javax.annotation.Nullable
  private Boolean generateDistinctId;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  @javax.annotation.Nullable
  private String value;

  public static final String SERIALIZED_NAME_STAGE_KEYS = "stageKeys";
  @SerializedName(SERIALIZED_NAME_STAGE_KEYS)
  @javax.annotation.Nullable
  private List<StageKey> stageKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_CUSTOMER_ID = "customerId";
  @SerializedName(SERIALIZED_NAME_CUSTOMER_ID)
  @javax.annotation.Nullable
  private String customerId;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Map<String, String> tags = new HashMap<>();

  public CreateApiKeyRequest() {
  }

  public CreateApiKeyRequest name(@javax.annotation.Nullable String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the ApiKey.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public CreateApiKeyRequest description(@javax.annotation.Nullable String description) {
    this.description = description;
    return this;
  }

  /**
   * The description of the ApiKey.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(@javax.annotation.Nullable String description) {
    this.description = description;
  }


  public CreateApiKeyRequest enabled(@javax.annotation.Nullable Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * Specifies whether the ApiKey can be used by callers.
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(@javax.annotation.Nullable Boolean enabled) {
    this.enabled = enabled;
  }


  public CreateApiKeyRequest generateDistinctId(@javax.annotation.Nullable Boolean generateDistinctId) {
    this.generateDistinctId = generateDistinctId;
    return this;
  }

  /**
   * Specifies whether (&lt;code&gt;true&lt;/code&gt;) or not (&lt;code&gt;false&lt;/code&gt;) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.
   * @return generateDistinctId
   */
  @javax.annotation.Nullable
  public Boolean getGenerateDistinctId() {
    return generateDistinctId;
  }

  public void setGenerateDistinctId(@javax.annotation.Nullable Boolean generateDistinctId) {
    this.generateDistinctId = generateDistinctId;
  }


  public CreateApiKeyRequest value(@javax.annotation.Nullable String value) {
    this.value = value;
    return this;
  }

  /**
   * Specifies a value of the API key.
   * @return value
   */
  @javax.annotation.Nullable
  public String getValue() {
    return value;
  }

  public void setValue(@javax.annotation.Nullable String value) {
    this.value = value;
  }


  public CreateApiKeyRequest stageKeys(@javax.annotation.Nullable List<StageKey> stageKeys) {
    this.stageKeys = stageKeys;
    return this;
  }

  public CreateApiKeyRequest addStageKeysItem(StageKey stageKeysItem) {
    if (this.stageKeys == null) {
      this.stageKeys = new ArrayList<>();
    }
    this.stageKeys.add(stageKeysItem);
    return this;
  }

  /**
   * DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.
   * @return stageKeys
   */
  @javax.annotation.Nullable
  public List<StageKey> getStageKeys() {
    return stageKeys;
  }

  public void setStageKeys(@javax.annotation.Nullable List<StageKey> stageKeys) {
    this.stageKeys = stageKeys;
  }


  public CreateApiKeyRequest customerId(@javax.annotation.Nullable String customerId) {
    this.customerId = customerId;
    return this;
  }

  /**
   * An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.
   * @return customerId
   */
  @javax.annotation.Nullable
  public String getCustomerId() {
    return customerId;
  }

  public void setCustomerId(@javax.annotation.Nullable String customerId) {
    this.customerId = customerId;
  }


  public CreateApiKeyRequest tags(@javax.annotation.Nullable Map<String, String> tags) {
    this.tags = tags;
    return this;
  }

  public CreateApiKeyRequest putTagsItem(String key, String tagsItem) {
    if (this.tags == null) {
      this.tags = new HashMap<>();
    }
    this.tags.put(key, tagsItem);
    return this;
  }

  /**
   * The key-value map of strings. The valid character set is [a-zA-Z+-&#x3D;._:/]. The tag key can be up to 128 characters and must not start with &lt;code&gt;aws:&lt;/code&gt;. The tag value can be up to 256 characters.
   * @return tags
   */
  @javax.annotation.Nullable
  public Map<String, String> getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Map<String, String> tags) {
    this.tags = tags;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateApiKeyRequest createApiKeyRequest = (CreateApiKeyRequest) o;
    return Objects.equals(this.name, createApiKeyRequest.name) &&
        Objects.equals(this.description, createApiKeyRequest.description) &&
        Objects.equals(this.enabled, createApiKeyRequest.enabled) &&
        Objects.equals(this.generateDistinctId, createApiKeyRequest.generateDistinctId) &&
        Objects.equals(this.value, createApiKeyRequest.value) &&
        Objects.equals(this.stageKeys, createApiKeyRequest.stageKeys) &&
        Objects.equals(this.customerId, createApiKeyRequest.customerId) &&
        Objects.equals(this.tags, createApiKeyRequest.tags);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, description, enabled, generateDistinctId, value, stageKeys, customerId, tags);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateApiKeyRequest {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    generateDistinctId: ").append(toIndentedString(generateDistinctId)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    stageKeys: ").append(toIndentedString(stageKeys)).append("\n");
    sb.append("    customerId: ").append(toIndentedString(customerId)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("description");
    openapiFields.add("enabled");
    openapiFields.add("generateDistinctId");
    openapiFields.add("value");
    openapiFields.add("stageKeys");
    openapiFields.add("customerId");
    openapiFields.add("tags");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateApiKeyRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateApiKeyRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateApiKeyRequest is not found in the empty JSON string", CreateApiKeyRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateApiKeyRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateApiKeyRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("value") != null && !jsonObj.get("value").isJsonNull()) && !jsonObj.get("value").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `value` to be a primitive type in the JSON string but got `%s`", jsonObj.get("value").toString()));
      }
      if (jsonObj.get("stageKeys") != null && !jsonObj.get("stageKeys").isJsonNull()) {
        JsonArray jsonArraystageKeys = jsonObj.getAsJsonArray("stageKeys");
        if (jsonArraystageKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("stageKeys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `stageKeys` to be an array in the JSON string but got `%s`", jsonObj.get("stageKeys").toString()));
          }

          // validate the optional field `stageKeys` (array)
          for (int i = 0; i < jsonArraystageKeys.size(); i++) {
            StageKey.validateJsonElement(jsonArraystageKeys.get(i));
          };
        }
      }
      if ((jsonObj.get("customerId") != null && !jsonObj.get("customerId").isJsonNull()) && !jsonObj.get("customerId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customerId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customerId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateApiKeyRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateApiKeyRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateApiKeyRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateApiKeyRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateApiKeyRequest>() {
           @Override
           public void write(JsonWriter out, CreateApiKeyRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateApiKeyRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateApiKeyRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateApiKeyRequest
   * @throws IOException if the JSON string is invalid with respect to CreateApiKeyRequest
   */
  public static CreateApiKeyRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateApiKeyRequest.class);
  }

  /**
   * Convert an instance of CreateApiKeyRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

