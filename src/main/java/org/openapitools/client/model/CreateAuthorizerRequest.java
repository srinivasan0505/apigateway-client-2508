/*
 * Amazon API Gateway
 * <fullname>Amazon API Gateway</fullname> <p>Amazon API Gateway helps developers deliver robust, secure, and scalable mobile and web application back ends. API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.</p>
 *
 * The version of the OpenAPI document: 2015-07-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateAuthorizerRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T13:10:54.869209+05:30[Asia/Kolkata]", comments = "Generator version: 7.10.0")
public class CreateAuthorizerRequest {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  /**
   * The authorizer type. Valid values are &lt;code&gt;TOKEN&lt;/code&gt; for a Lambda function using a single authorization token submitted in a custom header, &lt;code&gt;REQUEST&lt;/code&gt; for a Lambda function using incoming request parameters, and &lt;code&gt;COGNITO_USER_POOLS&lt;/code&gt; for using an Amazon Cognito user pool.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    TOKEN("TOKEN"),
    
    REQUEST("REQUEST"),
    
    COGNITO_USER_POOLS("COGNITO_USER_POOLS");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  @javax.annotation.Nonnull
  private TypeEnum type;

  public static final String SERIALIZED_NAME_PROVIDER_A_R_NS = "providerARNs";
  @SerializedName(SERIALIZED_NAME_PROVIDER_A_R_NS)
  @javax.annotation.Nullable
  private List<String> providerARNs = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUTH_TYPE = "authType";
  @SerializedName(SERIALIZED_NAME_AUTH_TYPE)
  @javax.annotation.Nullable
  private String authType;

  public static final String SERIALIZED_NAME_AUTHORIZER_URI = "authorizerUri";
  @SerializedName(SERIALIZED_NAME_AUTHORIZER_URI)
  @javax.annotation.Nullable
  private String authorizerUri;

  public static final String SERIALIZED_NAME_AUTHORIZER_CREDENTIALS = "authorizerCredentials";
  @SerializedName(SERIALIZED_NAME_AUTHORIZER_CREDENTIALS)
  @javax.annotation.Nullable
  private String authorizerCredentials;

  public static final String SERIALIZED_NAME_IDENTITY_SOURCE = "identitySource";
  @SerializedName(SERIALIZED_NAME_IDENTITY_SOURCE)
  @javax.annotation.Nullable
  private String identitySource;

  public static final String SERIALIZED_NAME_IDENTITY_VALIDATION_EXPRESSION = "identityValidationExpression";
  @SerializedName(SERIALIZED_NAME_IDENTITY_VALIDATION_EXPRESSION)
  @javax.annotation.Nullable
  private String identityValidationExpression;

  public static final String SERIALIZED_NAME_AUTHORIZER_RESULT_TTL_IN_SECONDS = "authorizerResultTtlInSeconds";
  @SerializedName(SERIALIZED_NAME_AUTHORIZER_RESULT_TTL_IN_SECONDS)
  @javax.annotation.Nullable
  private Integer authorizerResultTtlInSeconds;

  public CreateAuthorizerRequest() {
  }

  public CreateAuthorizerRequest name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the authorizer.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public CreateAuthorizerRequest type(@javax.annotation.Nonnull TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * The authorizer type. Valid values are &lt;code&gt;TOKEN&lt;/code&gt; for a Lambda function using a single authorization token submitted in a custom header, &lt;code&gt;REQUEST&lt;/code&gt; for a Lambda function using incoming request parameters, and &lt;code&gt;COGNITO_USER_POOLS&lt;/code&gt; for using an Amazon Cognito user pool.
   * @return type
   */
  @javax.annotation.Nonnull
  public TypeEnum getType() {
    return type;
  }

  public void setType(@javax.annotation.Nonnull TypeEnum type) {
    this.type = type;
  }


  public CreateAuthorizerRequest providerARNs(@javax.annotation.Nullable List<String> providerARNs) {
    this.providerARNs = providerARNs;
    return this;
  }

  public CreateAuthorizerRequest addProviderARNsItem(String providerARNsItem) {
    if (this.providerARNs == null) {
      this.providerARNs = new ArrayList<>();
    }
    this.providerARNs.add(providerARNsItem);
    return this;
  }

  /**
   * A list of the Amazon Cognito user pool ARNs for the &lt;code&gt;COGNITO_USER_POOLS&lt;/code&gt; authorizer. Each element is of this format: &lt;code&gt;arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}&lt;/code&gt;. For a &lt;code&gt;TOKEN&lt;/code&gt; or &lt;code&gt;REQUEST&lt;/code&gt; authorizer, this is not defined. 
   * @return providerARNs
   */
  @javax.annotation.Nullable
  public List<String> getProviderARNs() {
    return providerARNs;
  }

  public void setProviderARNs(@javax.annotation.Nullable List<String> providerARNs) {
    this.providerARNs = providerARNs;
  }


  public CreateAuthorizerRequest authType(@javax.annotation.Nullable String authType) {
    this.authType = authType;
    return this;
  }

  /**
   * Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
   * @return authType
   */
  @javax.annotation.Nullable
  public String getAuthType() {
    return authType;
  }

  public void setAuthType(@javax.annotation.Nullable String authType) {
    this.authType = authType;
  }


  public CreateAuthorizerRequest authorizerUri(@javax.annotation.Nullable String authorizerUri) {
    this.authorizerUri = authorizerUri;
    return this;
  }

  /**
   * Specifies the authorizer&#39;s Uniform Resource Identifier (URI). For &lt;code&gt;TOKEN&lt;/code&gt; or &lt;code&gt;REQUEST&lt;/code&gt; authorizers, this must be a well-formed Lambda function URI, for example, &lt;code&gt;arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations&lt;/code&gt;. In general, the URI has this form &lt;code&gt;arn:aws:apigateway:{region}:lambda:path/{service_api}&lt;/code&gt;, where &lt;code&gt;{region}&lt;/code&gt; is the same as the region hosting the Lambda function, &lt;code&gt;path&lt;/code&gt; indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial &lt;code&gt;/&lt;/code&gt;. For Lambda functions, this is usually of the form &lt;code&gt;/2015-03-31/functions/[FunctionARN]/invocations&lt;/code&gt;.
   * @return authorizerUri
   */
  @javax.annotation.Nullable
  public String getAuthorizerUri() {
    return authorizerUri;
  }

  public void setAuthorizerUri(@javax.annotation.Nullable String authorizerUri) {
    this.authorizerUri = authorizerUri;
  }


  public CreateAuthorizerRequest authorizerCredentials(@javax.annotation.Nullable String authorizerCredentials) {
    this.authorizerCredentials = authorizerCredentials;
    return this;
  }

  /**
   * Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role&#39;s Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
   * @return authorizerCredentials
   */
  @javax.annotation.Nullable
  public String getAuthorizerCredentials() {
    return authorizerCredentials;
  }

  public void setAuthorizerCredentials(@javax.annotation.Nullable String authorizerCredentials) {
    this.authorizerCredentials = authorizerCredentials;
  }


  public CreateAuthorizerRequest identitySource(@javax.annotation.Nullable String identitySource) {
    this.identitySource = identitySource;
    return this;
  }

  /**
   * The identity source for which authorization is requested. For a &lt;code&gt;TOKEN&lt;/code&gt; or &lt;code&gt;COGNITO_USER_POOLS&lt;/code&gt; authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is &lt;code&gt;Auth&lt;/code&gt;, the header mapping expression is &lt;code&gt;method.request.header.Auth&lt;/code&gt;. For the &lt;code&gt;REQUEST&lt;/code&gt; authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an &lt;code&gt;Auth&lt;/code&gt; header, a &lt;code&gt;Name&lt;/code&gt; query string parameter are defined as identity sources, this value is &lt;code&gt;method.request.header.Auth, method.request.querystring.Name&lt;/code&gt;. These parameters will be used to derive the authorization caching key and to perform runtime validation of the &lt;code&gt;REQUEST&lt;/code&gt; authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
   * @return identitySource
   */
  @javax.annotation.Nullable
  public String getIdentitySource() {
    return identitySource;
  }

  public void setIdentitySource(@javax.annotation.Nullable String identitySource) {
    this.identitySource = identitySource;
  }


  public CreateAuthorizerRequest identityValidationExpression(@javax.annotation.Nullable String identityValidationExpression) {
    this.identityValidationExpression = identityValidationExpression;
    return this;
  }

  /**
   * A validation expression for the incoming identity token. For &lt;code&gt;TOKEN&lt;/code&gt; authorizers, this value is a regular expression. For &lt;code&gt;COGNITO_USER_POOLS&lt;/code&gt; authorizers, API Gateway will match the &lt;code&gt;aud&lt;/code&gt; field of the incoming token from the client against the specified regular expression. It will invoke the authorizer&#39;s Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the &lt;code&gt;REQUEST&lt;/code&gt; authorizer.
   * @return identityValidationExpression
   */
  @javax.annotation.Nullable
  public String getIdentityValidationExpression() {
    return identityValidationExpression;
  }

  public void setIdentityValidationExpression(@javax.annotation.Nullable String identityValidationExpression) {
    this.identityValidationExpression = identityValidationExpression;
  }


  public CreateAuthorizerRequest authorizerResultTtlInSeconds(@javax.annotation.Nullable Integer authorizerResultTtlInSeconds) {
    this.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds;
    return this;
  }

  /**
   * The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
   * @return authorizerResultTtlInSeconds
   */
  @javax.annotation.Nullable
  public Integer getAuthorizerResultTtlInSeconds() {
    return authorizerResultTtlInSeconds;
  }

  public void setAuthorizerResultTtlInSeconds(@javax.annotation.Nullable Integer authorizerResultTtlInSeconds) {
    this.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateAuthorizerRequest createAuthorizerRequest = (CreateAuthorizerRequest) o;
    return Objects.equals(this.name, createAuthorizerRequest.name) &&
        Objects.equals(this.type, createAuthorizerRequest.type) &&
        Objects.equals(this.providerARNs, createAuthorizerRequest.providerARNs) &&
        Objects.equals(this.authType, createAuthorizerRequest.authType) &&
        Objects.equals(this.authorizerUri, createAuthorizerRequest.authorizerUri) &&
        Objects.equals(this.authorizerCredentials, createAuthorizerRequest.authorizerCredentials) &&
        Objects.equals(this.identitySource, createAuthorizerRequest.identitySource) &&
        Objects.equals(this.identityValidationExpression, createAuthorizerRequest.identityValidationExpression) &&
        Objects.equals(this.authorizerResultTtlInSeconds, createAuthorizerRequest.authorizerResultTtlInSeconds);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, type, providerARNs, authType, authorizerUri, authorizerCredentials, identitySource, identityValidationExpression, authorizerResultTtlInSeconds);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateAuthorizerRequest {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    providerARNs: ").append(toIndentedString(providerARNs)).append("\n");
    sb.append("    authType: ").append(toIndentedString(authType)).append("\n");
    sb.append("    authorizerUri: ").append(toIndentedString(authorizerUri)).append("\n");
    sb.append("    authorizerCredentials: ").append(toIndentedString(authorizerCredentials)).append("\n");
    sb.append("    identitySource: ").append(toIndentedString(identitySource)).append("\n");
    sb.append("    identityValidationExpression: ").append(toIndentedString(identityValidationExpression)).append("\n");
    sb.append("    authorizerResultTtlInSeconds: ").append(toIndentedString(authorizerResultTtlInSeconds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("type");
    openapiFields.add("providerARNs");
    openapiFields.add("authType");
    openapiFields.add("authorizerUri");
    openapiFields.add("authorizerCredentials");
    openapiFields.add("identitySource");
    openapiFields.add("identityValidationExpression");
    openapiFields.add("authorizerResultTtlInSeconds");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateAuthorizerRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateAuthorizerRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateAuthorizerRequest is not found in the empty JSON string", CreateAuthorizerRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateAuthorizerRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateAuthorizerRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreateAuthorizerRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (!jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the required field `type`
      TypeEnum.validateJsonElement(jsonObj.get("type"));
      // ensure the optional json data is an array if present
      if (jsonObj.get("providerARNs") != null && !jsonObj.get("providerARNs").isJsonNull() && !jsonObj.get("providerARNs").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `providerARNs` to be an array in the JSON string but got `%s`", jsonObj.get("providerARNs").toString()));
      }
      if ((jsonObj.get("authType") != null && !jsonObj.get("authType").isJsonNull()) && !jsonObj.get("authType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authType").toString()));
      }
      if ((jsonObj.get("authorizerUri") != null && !jsonObj.get("authorizerUri").isJsonNull()) && !jsonObj.get("authorizerUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authorizerUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authorizerUri").toString()));
      }
      if ((jsonObj.get("authorizerCredentials") != null && !jsonObj.get("authorizerCredentials").isJsonNull()) && !jsonObj.get("authorizerCredentials").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authorizerCredentials` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authorizerCredentials").toString()));
      }
      if ((jsonObj.get("identitySource") != null && !jsonObj.get("identitySource").isJsonNull()) && !jsonObj.get("identitySource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `identitySource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("identitySource").toString()));
      }
      if ((jsonObj.get("identityValidationExpression") != null && !jsonObj.get("identityValidationExpression").isJsonNull()) && !jsonObj.get("identityValidationExpression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `identityValidationExpression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("identityValidationExpression").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateAuthorizerRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateAuthorizerRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateAuthorizerRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateAuthorizerRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateAuthorizerRequest>() {
           @Override
           public void write(JsonWriter out, CreateAuthorizerRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateAuthorizerRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateAuthorizerRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateAuthorizerRequest
   * @throws IOException if the JSON string is invalid with respect to CreateAuthorizerRequest
   */
  public static CreateAuthorizerRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateAuthorizerRequest.class);
  }

  /**
   * Convert an instance of CreateAuthorizerRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

