/*
 * Amazon API Gateway
 * <fullname>Amazon API Gateway</fullname> <p>Amazon API Gateway helps developers deliver robust, secure, and scalable mobile and web application back ends. API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.</p>
 *
 * The version of the OpenAPI document: 2015-07-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents the response of the test invoke request for a custom Authorizer
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T13:10:54.869209+05:30[Asia/Kolkata]", comments = "Generator version: 7.10.0")
public class TestInvokeAuthorizerResponse {
  public static final String SERIALIZED_NAME_CLIENT_STATUS = "clientStatus";
  @SerializedName(SERIALIZED_NAME_CLIENT_STATUS)
  @javax.annotation.Nullable
  private Integer clientStatus;

  public static final String SERIALIZED_NAME_LOG = "log";
  @SerializedName(SERIALIZED_NAME_LOG)
  @javax.annotation.Nullable
  private String log;

  public static final String SERIALIZED_NAME_LATENCY = "latency";
  @SerializedName(SERIALIZED_NAME_LATENCY)
  @javax.annotation.Nullable
  private Integer latency;

  public static final String SERIALIZED_NAME_PRINCIPAL_ID = "principalId";
  @SerializedName(SERIALIZED_NAME_PRINCIPAL_ID)
  @javax.annotation.Nullable
  private String principalId;

  public static final String SERIALIZED_NAME_POLICY = "policy";
  @SerializedName(SERIALIZED_NAME_POLICY)
  @javax.annotation.Nullable
  private String policy;

  public static final String SERIALIZED_NAME_AUTHORIZATION = "authorization";
  @SerializedName(SERIALIZED_NAME_AUTHORIZATION)
  @javax.annotation.Nullable
  private Map authorization;

  public static final String SERIALIZED_NAME_CLAIMS = "claims";
  @SerializedName(SERIALIZED_NAME_CLAIMS)
  @javax.annotation.Nullable
  private Map claims;

  public TestInvokeAuthorizerResponse() {
  }

  public TestInvokeAuthorizerResponse clientStatus(@javax.annotation.Nullable Integer clientStatus) {
    this.clientStatus = clientStatus;
    return this;
  }

  /**
   * Get clientStatus
   * @return clientStatus
   */
  @javax.annotation.Nullable
  public Integer getClientStatus() {
    return clientStatus;
  }

  public void setClientStatus(@javax.annotation.Nullable Integer clientStatus) {
    this.clientStatus = clientStatus;
  }


  public TestInvokeAuthorizerResponse log(@javax.annotation.Nullable String log) {
    this.log = log;
    return this;
  }

  /**
   * Get log
   * @return log
   */
  @javax.annotation.Nullable
  public String getLog() {
    return log;
  }

  public void setLog(@javax.annotation.Nullable String log) {
    this.log = log;
  }


  public TestInvokeAuthorizerResponse latency(@javax.annotation.Nullable Integer latency) {
    this.latency = latency;
    return this;
  }

  /**
   * Get latency
   * @return latency
   */
  @javax.annotation.Nullable
  public Integer getLatency() {
    return latency;
  }

  public void setLatency(@javax.annotation.Nullable Integer latency) {
    this.latency = latency;
  }


  public TestInvokeAuthorizerResponse principalId(@javax.annotation.Nullable String principalId) {
    this.principalId = principalId;
    return this;
  }

  /**
   * Get principalId
   * @return principalId
   */
  @javax.annotation.Nullable
  public String getPrincipalId() {
    return principalId;
  }

  public void setPrincipalId(@javax.annotation.Nullable String principalId) {
    this.principalId = principalId;
  }


  public TestInvokeAuthorizerResponse policy(@javax.annotation.Nullable String policy) {
    this.policy = policy;
    return this;
  }

  /**
   * Get policy
   * @return policy
   */
  @javax.annotation.Nullable
  public String getPolicy() {
    return policy;
  }

  public void setPolicy(@javax.annotation.Nullable String policy) {
    this.policy = policy;
  }


  public TestInvokeAuthorizerResponse authorization(@javax.annotation.Nullable Map authorization) {
    this.authorization = authorization;
    return this;
  }

  /**
   * Get authorization
   * @return authorization
   */
  @javax.annotation.Nullable
  public Map getAuthorization() {
    return authorization;
  }

  public void setAuthorization(@javax.annotation.Nullable Map authorization) {
    this.authorization = authorization;
  }


  public TestInvokeAuthorizerResponse claims(@javax.annotation.Nullable Map claims) {
    this.claims = claims;
    return this;
  }

  /**
   * Get claims
   * @return claims
   */
  @javax.annotation.Nullable
  public Map getClaims() {
    return claims;
  }

  public void setClaims(@javax.annotation.Nullable Map claims) {
    this.claims = claims;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestInvokeAuthorizerResponse testInvokeAuthorizerResponse = (TestInvokeAuthorizerResponse) o;
    return Objects.equals(this.clientStatus, testInvokeAuthorizerResponse.clientStatus) &&
        Objects.equals(this.log, testInvokeAuthorizerResponse.log) &&
        Objects.equals(this.latency, testInvokeAuthorizerResponse.latency) &&
        Objects.equals(this.principalId, testInvokeAuthorizerResponse.principalId) &&
        Objects.equals(this.policy, testInvokeAuthorizerResponse.policy) &&
        Objects.equals(this.authorization, testInvokeAuthorizerResponse.authorization) &&
        Objects.equals(this.claims, testInvokeAuthorizerResponse.claims);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientStatus, log, latency, principalId, policy, authorization, claims);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestInvokeAuthorizerResponse {\n");
    sb.append("    clientStatus: ").append(toIndentedString(clientStatus)).append("\n");
    sb.append("    log: ").append(toIndentedString(log)).append("\n");
    sb.append("    latency: ").append(toIndentedString(latency)).append("\n");
    sb.append("    principalId: ").append(toIndentedString(principalId)).append("\n");
    sb.append("    policy: ").append(toIndentedString(policy)).append("\n");
    sb.append("    authorization: ").append(toIndentedString(authorization)).append("\n");
    sb.append("    claims: ").append(toIndentedString(claims)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("clientStatus");
    openapiFields.add("log");
    openapiFields.add("latency");
    openapiFields.add("principalId");
    openapiFields.add("policy");
    openapiFields.add("authorization");
    openapiFields.add("claims");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TestInvokeAuthorizerResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TestInvokeAuthorizerResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestInvokeAuthorizerResponse is not found in the empty JSON string", TestInvokeAuthorizerResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TestInvokeAuthorizerResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TestInvokeAuthorizerResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `clientStatus`
      if (jsonObj.get("clientStatus") != null && !jsonObj.get("clientStatus").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("clientStatus"));
      }
      // validate the optional field `log`
      if (jsonObj.get("log") != null && !jsonObj.get("log").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("log"));
      }
      // validate the optional field `latency`
      if (jsonObj.get("latency") != null && !jsonObj.get("latency").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("latency"));
      }
      // validate the optional field `principalId`
      if (jsonObj.get("principalId") != null && !jsonObj.get("principalId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("principalId"));
      }
      // validate the optional field `policy`
      if (jsonObj.get("policy") != null && !jsonObj.get("policy").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("policy"));
      }
      // validate the optional field `authorization`
      if (jsonObj.get("authorization") != null && !jsonObj.get("authorization").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("authorization"));
      }
      // validate the optional field `claims`
      if (jsonObj.get("claims") != null && !jsonObj.get("claims").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("claims"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestInvokeAuthorizerResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestInvokeAuthorizerResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestInvokeAuthorizerResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestInvokeAuthorizerResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<TestInvokeAuthorizerResponse>() {
           @Override
           public void write(JsonWriter out, TestInvokeAuthorizerResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestInvokeAuthorizerResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TestInvokeAuthorizerResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TestInvokeAuthorizerResponse
   * @throws IOException if the JSON string is invalid with respect to TestInvokeAuthorizerResponse
   */
  public static TestInvokeAuthorizerResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestInvokeAuthorizerResponse.class);
  }

  /**
   * Convert an instance of TestInvokeAuthorizerResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

