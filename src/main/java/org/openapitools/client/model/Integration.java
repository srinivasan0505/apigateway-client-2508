/*
 * Amazon API Gateway
 * <fullname>Amazon API Gateway</fullname> <p>Amazon API Gateway helps developers deliver robust, secure, and scalable mobile and web application back ends. API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.</p>
 *
 * The version of the OpenAPI document: 2015-07-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ConnectionType;
import org.openapitools.client.model.ContentHandlingStrategy;
import org.openapitools.client.model.IntegrationTlsConfig;
import org.openapitools.client.model.IntegrationType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T13:10:54.869209+05:30[Asia/Kolkata]", comments = "Generator version: 7.10.0")
public class Integration {
  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  @javax.annotation.Nullable
  private IntegrationType type;

  public static final String SERIALIZED_NAME_HTTP_METHOD = "httpMethod";
  @SerializedName(SERIALIZED_NAME_HTTP_METHOD)
  @javax.annotation.Nullable
  private String httpMethod;

  public static final String SERIALIZED_NAME_URI = "uri";
  @SerializedName(SERIALIZED_NAME_URI)
  @javax.annotation.Nullable
  private String uri;

  public static final String SERIALIZED_NAME_CONNECTION_TYPE = "connectionType";
  @SerializedName(SERIALIZED_NAME_CONNECTION_TYPE)
  @javax.annotation.Nullable
  private ConnectionType connectionType;

  public static final String SERIALIZED_NAME_CONNECTION_ID = "connectionId";
  @SerializedName(SERIALIZED_NAME_CONNECTION_ID)
  @javax.annotation.Nullable
  private String connectionId;

  public static final String SERIALIZED_NAME_CREDENTIALS = "credentials";
  @SerializedName(SERIALIZED_NAME_CREDENTIALS)
  @javax.annotation.Nullable
  private String credentials;

  public static final String SERIALIZED_NAME_REQUEST_PARAMETERS = "requestParameters";
  @SerializedName(SERIALIZED_NAME_REQUEST_PARAMETERS)
  @javax.annotation.Nullable
  private Map requestParameters;

  public static final String SERIALIZED_NAME_REQUEST_TEMPLATES = "requestTemplates";
  @SerializedName(SERIALIZED_NAME_REQUEST_TEMPLATES)
  @javax.annotation.Nullable
  private Map requestTemplates;

  public static final String SERIALIZED_NAME_PASSTHROUGH_BEHAVIOR = "passthroughBehavior";
  @SerializedName(SERIALIZED_NAME_PASSTHROUGH_BEHAVIOR)
  @javax.annotation.Nullable
  private String passthroughBehavior;

  public static final String SERIALIZED_NAME_CONTENT_HANDLING = "contentHandling";
  @SerializedName(SERIALIZED_NAME_CONTENT_HANDLING)
  @javax.annotation.Nullable
  private ContentHandlingStrategy contentHandling;

  public static final String SERIALIZED_NAME_TIMEOUT_IN_MILLIS = "timeoutInMillis";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_IN_MILLIS)
  @javax.annotation.Nullable
  private Integer timeoutInMillis;

  public static final String SERIALIZED_NAME_CACHE_NAMESPACE = "cacheNamespace";
  @SerializedName(SERIALIZED_NAME_CACHE_NAMESPACE)
  @javax.annotation.Nullable
  private String cacheNamespace;

  public static final String SERIALIZED_NAME_CACHE_KEY_PARAMETERS = "cacheKeyParameters";
  @SerializedName(SERIALIZED_NAME_CACHE_KEY_PARAMETERS)
  @javax.annotation.Nullable
  private List cacheKeyParameters;

  public static final String SERIALIZED_NAME_INTEGRATION_RESPONSES = "integrationResponses";
  @SerializedName(SERIALIZED_NAME_INTEGRATION_RESPONSES)
  @javax.annotation.Nullable
  private Map integrationResponses;

  public static final String SERIALIZED_NAME_TLS_CONFIG = "tlsConfig";
  @SerializedName(SERIALIZED_NAME_TLS_CONFIG)
  @javax.annotation.Nullable
  private IntegrationTlsConfig tlsConfig;

  public Integration() {
  }

  public Integration type(@javax.annotation.Nullable IntegrationType type) {
    this.type = type;
    return this;
  }

  /**
   * Get type
   * @return type
   */
  @javax.annotation.Nullable
  public IntegrationType getType() {
    return type;
  }

  public void setType(@javax.annotation.Nullable IntegrationType type) {
    this.type = type;
  }


  public Integration httpMethod(@javax.annotation.Nullable String httpMethod) {
    this.httpMethod = httpMethod;
    return this;
  }

  /**
   * Get httpMethod
   * @return httpMethod
   */
  @javax.annotation.Nullable
  public String getHttpMethod() {
    return httpMethod;
  }

  public void setHttpMethod(@javax.annotation.Nullable String httpMethod) {
    this.httpMethod = httpMethod;
  }


  public Integration uri(@javax.annotation.Nullable String uri) {
    this.uri = uri;
    return this;
  }

  /**
   * Get uri
   * @return uri
   */
  @javax.annotation.Nullable
  public String getUri() {
    return uri;
  }

  public void setUri(@javax.annotation.Nullable String uri) {
    this.uri = uri;
  }


  public Integration connectionType(@javax.annotation.Nullable ConnectionType connectionType) {
    this.connectionType = connectionType;
    return this;
  }

  /**
   * Get connectionType
   * @return connectionType
   */
  @javax.annotation.Nullable
  public ConnectionType getConnectionType() {
    return connectionType;
  }

  public void setConnectionType(@javax.annotation.Nullable ConnectionType connectionType) {
    this.connectionType = connectionType;
  }


  public Integration connectionId(@javax.annotation.Nullable String connectionId) {
    this.connectionId = connectionId;
    return this;
  }

  /**
   * Get connectionId
   * @return connectionId
   */
  @javax.annotation.Nullable
  public String getConnectionId() {
    return connectionId;
  }

  public void setConnectionId(@javax.annotation.Nullable String connectionId) {
    this.connectionId = connectionId;
  }


  public Integration credentials(@javax.annotation.Nullable String credentials) {
    this.credentials = credentials;
    return this;
  }

  /**
   * Get credentials
   * @return credentials
   */
  @javax.annotation.Nullable
  public String getCredentials() {
    return credentials;
  }

  public void setCredentials(@javax.annotation.Nullable String credentials) {
    this.credentials = credentials;
  }


  public Integration requestParameters(@javax.annotation.Nullable Map requestParameters) {
    this.requestParameters = requestParameters;
    return this;
  }

  /**
   * Get requestParameters
   * @return requestParameters
   */
  @javax.annotation.Nullable
  public Map getRequestParameters() {
    return requestParameters;
  }

  public void setRequestParameters(@javax.annotation.Nullable Map requestParameters) {
    this.requestParameters = requestParameters;
  }


  public Integration requestTemplates(@javax.annotation.Nullable Map requestTemplates) {
    this.requestTemplates = requestTemplates;
    return this;
  }

  /**
   * Get requestTemplates
   * @return requestTemplates
   */
  @javax.annotation.Nullable
  public Map getRequestTemplates() {
    return requestTemplates;
  }

  public void setRequestTemplates(@javax.annotation.Nullable Map requestTemplates) {
    this.requestTemplates = requestTemplates;
  }


  public Integration passthroughBehavior(@javax.annotation.Nullable String passthroughBehavior) {
    this.passthroughBehavior = passthroughBehavior;
    return this;
  }

  /**
   * Get passthroughBehavior
   * @return passthroughBehavior
   */
  @javax.annotation.Nullable
  public String getPassthroughBehavior() {
    return passthroughBehavior;
  }

  public void setPassthroughBehavior(@javax.annotation.Nullable String passthroughBehavior) {
    this.passthroughBehavior = passthroughBehavior;
  }


  public Integration contentHandling(@javax.annotation.Nullable ContentHandlingStrategy contentHandling) {
    this.contentHandling = contentHandling;
    return this;
  }

  /**
   * Get contentHandling
   * @return contentHandling
   */
  @javax.annotation.Nullable
  public ContentHandlingStrategy getContentHandling() {
    return contentHandling;
  }

  public void setContentHandling(@javax.annotation.Nullable ContentHandlingStrategy contentHandling) {
    this.contentHandling = contentHandling;
  }


  public Integration timeoutInMillis(@javax.annotation.Nullable Integer timeoutInMillis) {
    this.timeoutInMillis = timeoutInMillis;
    return this;
  }

  /**
   * Get timeoutInMillis
   * @return timeoutInMillis
   */
  @javax.annotation.Nullable
  public Integer getTimeoutInMillis() {
    return timeoutInMillis;
  }

  public void setTimeoutInMillis(@javax.annotation.Nullable Integer timeoutInMillis) {
    this.timeoutInMillis = timeoutInMillis;
  }


  public Integration cacheNamespace(@javax.annotation.Nullable String cacheNamespace) {
    this.cacheNamespace = cacheNamespace;
    return this;
  }

  /**
   * Get cacheNamespace
   * @return cacheNamespace
   */
  @javax.annotation.Nullable
  public String getCacheNamespace() {
    return cacheNamespace;
  }

  public void setCacheNamespace(@javax.annotation.Nullable String cacheNamespace) {
    this.cacheNamespace = cacheNamespace;
  }


  public Integration cacheKeyParameters(@javax.annotation.Nullable List cacheKeyParameters) {
    this.cacheKeyParameters = cacheKeyParameters;
    return this;
  }

  /**
   * Get cacheKeyParameters
   * @return cacheKeyParameters
   */
  @javax.annotation.Nullable
  public List getCacheKeyParameters() {
    return cacheKeyParameters;
  }

  public void setCacheKeyParameters(@javax.annotation.Nullable List cacheKeyParameters) {
    this.cacheKeyParameters = cacheKeyParameters;
  }


  public Integration integrationResponses(@javax.annotation.Nullable Map integrationResponses) {
    this.integrationResponses = integrationResponses;
    return this;
  }

  /**
   * Get integrationResponses
   * @return integrationResponses
   */
  @javax.annotation.Nullable
  public Map getIntegrationResponses() {
    return integrationResponses;
  }

  public void setIntegrationResponses(@javax.annotation.Nullable Map integrationResponses) {
    this.integrationResponses = integrationResponses;
  }


  public Integration tlsConfig(@javax.annotation.Nullable IntegrationTlsConfig tlsConfig) {
    this.tlsConfig = tlsConfig;
    return this;
  }

  /**
   * Get tlsConfig
   * @return tlsConfig
   */
  @javax.annotation.Nullable
  public IntegrationTlsConfig getTlsConfig() {
    return tlsConfig;
  }

  public void setTlsConfig(@javax.annotation.Nullable IntegrationTlsConfig tlsConfig) {
    this.tlsConfig = tlsConfig;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Integration integration = (Integration) o;
    return Objects.equals(this.type, integration.type) &&
        Objects.equals(this.httpMethod, integration.httpMethod) &&
        Objects.equals(this.uri, integration.uri) &&
        Objects.equals(this.connectionType, integration.connectionType) &&
        Objects.equals(this.connectionId, integration.connectionId) &&
        Objects.equals(this.credentials, integration.credentials) &&
        Objects.equals(this.requestParameters, integration.requestParameters) &&
        Objects.equals(this.requestTemplates, integration.requestTemplates) &&
        Objects.equals(this.passthroughBehavior, integration.passthroughBehavior) &&
        Objects.equals(this.contentHandling, integration.contentHandling) &&
        Objects.equals(this.timeoutInMillis, integration.timeoutInMillis) &&
        Objects.equals(this.cacheNamespace, integration.cacheNamespace) &&
        Objects.equals(this.cacheKeyParameters, integration.cacheKeyParameters) &&
        Objects.equals(this.integrationResponses, integration.integrationResponses) &&
        Objects.equals(this.tlsConfig, integration.tlsConfig);
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, httpMethod, uri, connectionType, connectionId, credentials, requestParameters, requestTemplates, passthroughBehavior, contentHandling, timeoutInMillis, cacheNamespace, cacheKeyParameters, integrationResponses, tlsConfig);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Integration {\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    httpMethod: ").append(toIndentedString(httpMethod)).append("\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    connectionType: ").append(toIndentedString(connectionType)).append("\n");
    sb.append("    connectionId: ").append(toIndentedString(connectionId)).append("\n");
    sb.append("    credentials: ").append(toIndentedString(credentials)).append("\n");
    sb.append("    requestParameters: ").append(toIndentedString(requestParameters)).append("\n");
    sb.append("    requestTemplates: ").append(toIndentedString(requestTemplates)).append("\n");
    sb.append("    passthroughBehavior: ").append(toIndentedString(passthroughBehavior)).append("\n");
    sb.append("    contentHandling: ").append(toIndentedString(contentHandling)).append("\n");
    sb.append("    timeoutInMillis: ").append(toIndentedString(timeoutInMillis)).append("\n");
    sb.append("    cacheNamespace: ").append(toIndentedString(cacheNamespace)).append("\n");
    sb.append("    cacheKeyParameters: ").append(toIndentedString(cacheKeyParameters)).append("\n");
    sb.append("    integrationResponses: ").append(toIndentedString(integrationResponses)).append("\n");
    sb.append("    tlsConfig: ").append(toIndentedString(tlsConfig)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("type");
    openapiFields.add("httpMethod");
    openapiFields.add("uri");
    openapiFields.add("connectionType");
    openapiFields.add("connectionId");
    openapiFields.add("credentials");
    openapiFields.add("requestParameters");
    openapiFields.add("requestTemplates");
    openapiFields.add("passthroughBehavior");
    openapiFields.add("contentHandling");
    openapiFields.add("timeoutInMillis");
    openapiFields.add("cacheNamespace");
    openapiFields.add("cacheKeyParameters");
    openapiFields.add("integrationResponses");
    openapiFields.add("tlsConfig");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Integration
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Integration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Integration is not found in the empty JSON string", Integration.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Integration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Integration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        IntegrationType.validateJsonElement(jsonObj.get("type"));
      }
      // validate the optional field `httpMethod`
      if (jsonObj.get("httpMethod") != null && !jsonObj.get("httpMethod").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("httpMethod"));
      }
      // validate the optional field `uri`
      if (jsonObj.get("uri") != null && !jsonObj.get("uri").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("uri"));
      }
      // validate the optional field `connectionType`
      if (jsonObj.get("connectionType") != null && !jsonObj.get("connectionType").isJsonNull()) {
        ConnectionType.validateJsonElement(jsonObj.get("connectionType"));
      }
      // validate the optional field `connectionId`
      if (jsonObj.get("connectionId") != null && !jsonObj.get("connectionId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("connectionId"));
      }
      // validate the optional field `credentials`
      if (jsonObj.get("credentials") != null && !jsonObj.get("credentials").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("credentials"));
      }
      // validate the optional field `requestParameters`
      if (jsonObj.get("requestParameters") != null && !jsonObj.get("requestParameters").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("requestParameters"));
      }
      // validate the optional field `requestTemplates`
      if (jsonObj.get("requestTemplates") != null && !jsonObj.get("requestTemplates").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("requestTemplates"));
      }
      // validate the optional field `passthroughBehavior`
      if (jsonObj.get("passthroughBehavior") != null && !jsonObj.get("passthroughBehavior").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("passthroughBehavior"));
      }
      // validate the optional field `contentHandling`
      if (jsonObj.get("contentHandling") != null && !jsonObj.get("contentHandling").isJsonNull()) {
        ContentHandlingStrategy.validateJsonElement(jsonObj.get("contentHandling"));
      }
      // validate the optional field `timeoutInMillis`
      if (jsonObj.get("timeoutInMillis") != null && !jsonObj.get("timeoutInMillis").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("timeoutInMillis"));
      }
      // validate the optional field `cacheNamespace`
      if (jsonObj.get("cacheNamespace") != null && !jsonObj.get("cacheNamespace").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("cacheNamespace"));
      }
      // validate the optional field `cacheKeyParameters`
      if (jsonObj.get("cacheKeyParameters") != null && !jsonObj.get("cacheKeyParameters").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("cacheKeyParameters"));
      }
      // validate the optional field `integrationResponses`
      if (jsonObj.get("integrationResponses") != null && !jsonObj.get("integrationResponses").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("integrationResponses"));
      }
      // validate the optional field `tlsConfig`
      if (jsonObj.get("tlsConfig") != null && !jsonObj.get("tlsConfig").isJsonNull()) {
        IntegrationTlsConfig.validateJsonElement(jsonObj.get("tlsConfig"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Integration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Integration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Integration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Integration.class));

       return (TypeAdapter<T>) new TypeAdapter<Integration>() {
           @Override
           public void write(JsonWriter out, Integration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Integration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Integration given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Integration
   * @throws IOException if the JSON string is invalid with respect to Integration
   */
  public static Integration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Integration.class);
  }

  /**
   * Convert an instance of Integration to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

