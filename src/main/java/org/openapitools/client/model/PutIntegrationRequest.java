/*
 * Amazon API Gateway
 * <fullname>Amazon API Gateway</fullname> <p>Amazon API Gateway helps developers deliver robust, secure, and scalable mobile and web application back ends. API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.</p>
 *
 * The version of the OpenAPI document: 2015-07-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.PutIntegrationRequestTlsConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * PutIntegrationRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T13:10:54.869209+05:30[Asia/Kolkata]", comments = "Generator version: 7.10.0")
public class PutIntegrationRequest {
  /**
   * The integration type. The valid value is &lt;code&gt;HTTP&lt;/code&gt; for integrating an API method with an HTTP backend; &lt;code&gt;AWS&lt;/code&gt; with any AWS service endpoints; &lt;code&gt;MOCK&lt;/code&gt; for testing without actually invoking the backend; &lt;code&gt;HTTP_PROXY&lt;/code&gt; for integrating with the HTTP proxy integration; &lt;code&gt;AWS_PROXY&lt;/code&gt; for integrating with the Lambda proxy integration. 
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    HTTP("HTTP"),
    
    AWS("AWS"),
    
    MOCK("MOCK"),
    
    HTTP_PROXY("HTTP_PROXY"),
    
    AWS_PROXY("AWS_PROXY");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  @javax.annotation.Nonnull
  private TypeEnum type;

  public static final String SERIALIZED_NAME_HTTP_METHOD = "httpMethod";
  @SerializedName(SERIALIZED_NAME_HTTP_METHOD)
  @javax.annotation.Nullable
  private String httpMethod;

  public static final String SERIALIZED_NAME_URI = "uri";
  @SerializedName(SERIALIZED_NAME_URI)
  @javax.annotation.Nullable
  private String uri;

  /**
   * The type of the network connection to the integration endpoint. The valid value is &lt;code&gt;INTERNET&lt;/code&gt; for connections through the public routable internet or &lt;code&gt;VPC_LINK&lt;/code&gt; for private connections between API Gateway and a network load balancer in a VPC. The default value is &lt;code&gt;INTERNET&lt;/code&gt;.
   */
  @JsonAdapter(ConnectionTypeEnum.Adapter.class)
  public enum ConnectionTypeEnum {
    INTERNET("INTERNET"),
    
    VPC_LINK("VPC_LINK");

    private String value;

    ConnectionTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ConnectionTypeEnum fromValue(String value) {
      for (ConnectionTypeEnum b : ConnectionTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ConnectionTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ConnectionTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ConnectionTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ConnectionTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ConnectionTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONNECTION_TYPE = "connectionType";
  @SerializedName(SERIALIZED_NAME_CONNECTION_TYPE)
  @javax.annotation.Nullable
  private ConnectionTypeEnum connectionType;

  public static final String SERIALIZED_NAME_CONNECTION_ID = "connectionId";
  @SerializedName(SERIALIZED_NAME_CONNECTION_ID)
  @javax.annotation.Nullable
  private String connectionId;

  public static final String SERIALIZED_NAME_CREDENTIALS = "credentials";
  @SerializedName(SERIALIZED_NAME_CREDENTIALS)
  @javax.annotation.Nullable
  private String credentials;

  public static final String SERIALIZED_NAME_REQUEST_PARAMETERS = "requestParameters";
  @SerializedName(SERIALIZED_NAME_REQUEST_PARAMETERS)
  @javax.annotation.Nullable
  private Map<String, String> requestParameters = new HashMap<>();

  public static final String SERIALIZED_NAME_REQUEST_TEMPLATES = "requestTemplates";
  @SerializedName(SERIALIZED_NAME_REQUEST_TEMPLATES)
  @javax.annotation.Nullable
  private Map<String, String> requestTemplates = new HashMap<>();

  public static final String SERIALIZED_NAME_PASSTHROUGH_BEHAVIOR = "passthroughBehavior";
  @SerializedName(SERIALIZED_NAME_PASSTHROUGH_BEHAVIOR)
  @javax.annotation.Nullable
  private String passthroughBehavior;

  public static final String SERIALIZED_NAME_CACHE_NAMESPACE = "cacheNamespace";
  @SerializedName(SERIALIZED_NAME_CACHE_NAMESPACE)
  @javax.annotation.Nullable
  private String cacheNamespace;

  public static final String SERIALIZED_NAME_CACHE_KEY_PARAMETERS = "cacheKeyParameters";
  @SerializedName(SERIALIZED_NAME_CACHE_KEY_PARAMETERS)
  @javax.annotation.Nullable
  private List<String> cacheKeyParameters = new ArrayList<>();

  /**
   * &lt;p&gt;Specifies how to handle request payload content type conversions. Supported values are &lt;code&gt;CONVERT_TO_BINARY&lt;/code&gt; and &lt;code&gt;CONVERT_TO_TEXT&lt;/code&gt;, with the following behaviors:&lt;/p&gt; &lt;p&gt;If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the &lt;code&gt;passthroughBehavior&lt;/code&gt; is configured to support payload pass-through.&lt;/p&gt;
   */
  @JsonAdapter(ContentHandlingEnum.Adapter.class)
  public enum ContentHandlingEnum {
    BINARY("CONVERT_TO_BINARY"),
    
    TEXT("CONVERT_TO_TEXT");

    private String value;

    ContentHandlingEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ContentHandlingEnum fromValue(String value) {
      for (ContentHandlingEnum b : ContentHandlingEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ContentHandlingEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ContentHandlingEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ContentHandlingEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ContentHandlingEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ContentHandlingEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONTENT_HANDLING = "contentHandling";
  @SerializedName(SERIALIZED_NAME_CONTENT_HANDLING)
  @javax.annotation.Nullable
  private ContentHandlingEnum contentHandling;

  public static final String SERIALIZED_NAME_TIMEOUT_IN_MILLIS = "timeoutInMillis";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_IN_MILLIS)
  @javax.annotation.Nullable
  private Integer timeoutInMillis;

  public static final String SERIALIZED_NAME_TLS_CONFIG = "tlsConfig";
  @SerializedName(SERIALIZED_NAME_TLS_CONFIG)
  @javax.annotation.Nullable
  private PutIntegrationRequestTlsConfig tlsConfig;

  public PutIntegrationRequest() {
  }

  public PutIntegrationRequest type(@javax.annotation.Nonnull TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * The integration type. The valid value is &lt;code&gt;HTTP&lt;/code&gt; for integrating an API method with an HTTP backend; &lt;code&gt;AWS&lt;/code&gt; with any AWS service endpoints; &lt;code&gt;MOCK&lt;/code&gt; for testing without actually invoking the backend; &lt;code&gt;HTTP_PROXY&lt;/code&gt; for integrating with the HTTP proxy integration; &lt;code&gt;AWS_PROXY&lt;/code&gt; for integrating with the Lambda proxy integration. 
   * @return type
   */
  @javax.annotation.Nonnull
  public TypeEnum getType() {
    return type;
  }

  public void setType(@javax.annotation.Nonnull TypeEnum type) {
    this.type = type;
  }


  public PutIntegrationRequest httpMethod(@javax.annotation.Nullable String httpMethod) {
    this.httpMethod = httpMethod;
    return this;
  }

  /**
   * The HTTP method for the integration.
   * @return httpMethod
   */
  @javax.annotation.Nullable
  public String getHttpMethod() {
    return httpMethod;
  }

  public void setHttpMethod(@javax.annotation.Nullable String httpMethod) {
    this.httpMethod = httpMethod;
  }


  public PutIntegrationRequest uri(@javax.annotation.Nullable String uri) {
    this.uri = uri;
    return this;
  }

  /**
   * Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or &lt;code&gt;HTTP_PROXY&lt;/code&gt; integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification, for either standard integration, where &lt;code&gt;connectionType&lt;/code&gt; is not &lt;code&gt;VPC_LINK&lt;/code&gt;, or private integration, where &lt;code&gt;connectionType&lt;/code&gt; is &lt;code&gt;VPC_LINK&lt;/code&gt;. For a private HTTP integration, the URI is not used for routing. For &lt;code&gt;AWS&lt;/code&gt; or &lt;code&gt;AWS_PROXY&lt;/code&gt; integrations, the URI is of the form &lt;code&gt;arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api&lt;/code&gt;}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action&#x3D;{name}&amp;amp;{p1}&#x3D;{v1}&amp;amp;p2&#x3D;{v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of &lt;code&gt;GetObject&lt;/code&gt;, the &lt;code&gt;uri&lt;/code&gt; can be either &lt;code&gt;arn:aws:apigateway:us-west-2:s3:action/GetObject&amp;amp;Bucket&#x3D;{bucket}&amp;amp;Key&#x3D;{key}&lt;/code&gt; or &lt;code&gt;arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}&lt;/code&gt;.
   * @return uri
   */
  @javax.annotation.Nullable
  public String getUri() {
    return uri;
  }

  public void setUri(@javax.annotation.Nullable String uri) {
    this.uri = uri;
  }


  public PutIntegrationRequest connectionType(@javax.annotation.Nullable ConnectionTypeEnum connectionType) {
    this.connectionType = connectionType;
    return this;
  }

  /**
   * The type of the network connection to the integration endpoint. The valid value is &lt;code&gt;INTERNET&lt;/code&gt; for connections through the public routable internet or &lt;code&gt;VPC_LINK&lt;/code&gt; for private connections between API Gateway and a network load balancer in a VPC. The default value is &lt;code&gt;INTERNET&lt;/code&gt;.
   * @return connectionType
   */
  @javax.annotation.Nullable
  public ConnectionTypeEnum getConnectionType() {
    return connectionType;
  }

  public void setConnectionType(@javax.annotation.Nullable ConnectionTypeEnum connectionType) {
    this.connectionType = connectionType;
  }


  public PutIntegrationRequest connectionId(@javax.annotation.Nullable String connectionId) {
    this.connectionId = connectionId;
    return this;
  }

  /**
   * The ID of the VpcLink used for the integration. Specify this value only if you specify &lt;code&gt;VPC_LINK&lt;/code&gt; as the connection type.
   * @return connectionId
   */
  @javax.annotation.Nullable
  public String getConnectionId() {
    return connectionId;
  }

  public void setConnectionId(@javax.annotation.Nullable String connectionId) {
    this.connectionId = connectionId;
  }


  public PutIntegrationRequest credentials(@javax.annotation.Nullable String credentials) {
    this.credentials = credentials;
    return this;
  }

  /**
   * Specifies whether credentials are required for a put integration.
   * @return credentials
   */
  @javax.annotation.Nullable
  public String getCredentials() {
    return credentials;
  }

  public void setCredentials(@javax.annotation.Nullable String credentials) {
    this.credentials = credentials;
  }


  public PutIntegrationRequest requestParameters(@javax.annotation.Nullable Map<String, String> requestParameters) {
    this.requestParameters = requestParameters;
    return this;
  }

  public PutIntegrationRequest putRequestParametersItem(String key, String requestParametersItem) {
    if (this.requestParameters == null) {
      this.requestParameters = new HashMap<>();
    }
    this.requestParameters.put(key, requestParametersItem);
    return this;
  }

  /**
   * A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of &lt;code&gt;method.request.{location}.{name}&lt;/code&gt;, where &lt;code&gt;location&lt;/code&gt; is &lt;code&gt;querystring&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, or &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; must be a valid and unique method request parameter name.
   * @return requestParameters
   */
  @javax.annotation.Nullable
  public Map<String, String> getRequestParameters() {
    return requestParameters;
  }

  public void setRequestParameters(@javax.annotation.Nullable Map<String, String> requestParameters) {
    this.requestParameters = requestParameters;
  }


  public PutIntegrationRequest requestTemplates(@javax.annotation.Nullable Map<String, String> requestTemplates) {
    this.requestTemplates = requestTemplates;
    return this;
  }

  public PutIntegrationRequest putRequestTemplatesItem(String key, String requestTemplatesItem) {
    if (this.requestTemplates == null) {
      this.requestTemplates = new HashMap<>();
    }
    this.requestTemplates.put(key, requestTemplatesItem);
    return this;
  }

  /**
   * Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
   * @return requestTemplates
   */
  @javax.annotation.Nullable
  public Map<String, String> getRequestTemplates() {
    return requestTemplates;
  }

  public void setRequestTemplates(@javax.annotation.Nullable Map<String, String> requestTemplates) {
    this.requestTemplates = requestTemplates;
  }


  public PutIntegrationRequest passthroughBehavior(@javax.annotation.Nullable String passthroughBehavior) {
    this.passthroughBehavior = passthroughBehavior;
    return this;
  }

  /**
   * Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the &lt;code&gt;requestTemplates&lt;/code&gt; property on the Integration resource. There are three valid values: &lt;code&gt;WHEN_NO_MATCH&lt;/code&gt;, &lt;code&gt;WHEN_NO_TEMPLATES&lt;/code&gt;, and &lt;code&gt;NEVER&lt;/code&gt;. 
   * @return passthroughBehavior
   */
  @javax.annotation.Nullable
  public String getPassthroughBehavior() {
    return passthroughBehavior;
  }

  public void setPassthroughBehavior(@javax.annotation.Nullable String passthroughBehavior) {
    this.passthroughBehavior = passthroughBehavior;
  }


  public PutIntegrationRequest cacheNamespace(@javax.annotation.Nullable String cacheNamespace) {
    this.cacheNamespace = cacheNamespace;
    return this;
  }

  /**
   * Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the &lt;code&gt;cacheNamespace&lt;/code&gt;. You can specify the same &lt;code&gt;cacheNamespace&lt;/code&gt; across resources to return the same cached data for requests to different resources.
   * @return cacheNamespace
   */
  @javax.annotation.Nullable
  public String getCacheNamespace() {
    return cacheNamespace;
  }

  public void setCacheNamespace(@javax.annotation.Nullable String cacheNamespace) {
    this.cacheNamespace = cacheNamespace;
  }


  public PutIntegrationRequest cacheKeyParameters(@javax.annotation.Nullable List<String> cacheKeyParameters) {
    this.cacheKeyParameters = cacheKeyParameters;
    return this;
  }

  public PutIntegrationRequest addCacheKeyParametersItem(String cacheKeyParametersItem) {
    if (this.cacheKeyParameters == null) {
      this.cacheKeyParameters = new ArrayList<>();
    }
    this.cacheKeyParameters.add(cacheKeyParametersItem);
    return this;
  }

  /**
   * A list of request parameters whose values API Gateway caches. To be valid values for &lt;code&gt;cacheKeyParameters&lt;/code&gt;, these parameters must also be specified for Method &lt;code&gt;requestParameters&lt;/code&gt;.
   * @return cacheKeyParameters
   */
  @javax.annotation.Nullable
  public List<String> getCacheKeyParameters() {
    return cacheKeyParameters;
  }

  public void setCacheKeyParameters(@javax.annotation.Nullable List<String> cacheKeyParameters) {
    this.cacheKeyParameters = cacheKeyParameters;
  }


  public PutIntegrationRequest contentHandling(@javax.annotation.Nullable ContentHandlingEnum contentHandling) {
    this.contentHandling = contentHandling;
    return this;
  }

  /**
   * &lt;p&gt;Specifies how to handle request payload content type conversions. Supported values are &lt;code&gt;CONVERT_TO_BINARY&lt;/code&gt; and &lt;code&gt;CONVERT_TO_TEXT&lt;/code&gt;, with the following behaviors:&lt;/p&gt; &lt;p&gt;If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the &lt;code&gt;passthroughBehavior&lt;/code&gt; is configured to support payload pass-through.&lt;/p&gt;
   * @return contentHandling
   */
  @javax.annotation.Nullable
  public ContentHandlingEnum getContentHandling() {
    return contentHandling;
  }

  public void setContentHandling(@javax.annotation.Nullable ContentHandlingEnum contentHandling) {
    this.contentHandling = contentHandling;
  }


  public PutIntegrationRequest timeoutInMillis(@javax.annotation.Nullable Integer timeoutInMillis) {
    this.timeoutInMillis = timeoutInMillis;
    return this;
  }

  /**
   * Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
   * @return timeoutInMillis
   */
  @javax.annotation.Nullable
  public Integer getTimeoutInMillis() {
    return timeoutInMillis;
  }

  public void setTimeoutInMillis(@javax.annotation.Nullable Integer timeoutInMillis) {
    this.timeoutInMillis = timeoutInMillis;
  }


  public PutIntegrationRequest tlsConfig(@javax.annotation.Nullable PutIntegrationRequestTlsConfig tlsConfig) {
    this.tlsConfig = tlsConfig;
    return this;
  }

  /**
   * Get tlsConfig
   * @return tlsConfig
   */
  @javax.annotation.Nullable
  public PutIntegrationRequestTlsConfig getTlsConfig() {
    return tlsConfig;
  }

  public void setTlsConfig(@javax.annotation.Nullable PutIntegrationRequestTlsConfig tlsConfig) {
    this.tlsConfig = tlsConfig;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PutIntegrationRequest putIntegrationRequest = (PutIntegrationRequest) o;
    return Objects.equals(this.type, putIntegrationRequest.type) &&
        Objects.equals(this.httpMethod, putIntegrationRequest.httpMethod) &&
        Objects.equals(this.uri, putIntegrationRequest.uri) &&
        Objects.equals(this.connectionType, putIntegrationRequest.connectionType) &&
        Objects.equals(this.connectionId, putIntegrationRequest.connectionId) &&
        Objects.equals(this.credentials, putIntegrationRequest.credentials) &&
        Objects.equals(this.requestParameters, putIntegrationRequest.requestParameters) &&
        Objects.equals(this.requestTemplates, putIntegrationRequest.requestTemplates) &&
        Objects.equals(this.passthroughBehavior, putIntegrationRequest.passthroughBehavior) &&
        Objects.equals(this.cacheNamespace, putIntegrationRequest.cacheNamespace) &&
        Objects.equals(this.cacheKeyParameters, putIntegrationRequest.cacheKeyParameters) &&
        Objects.equals(this.contentHandling, putIntegrationRequest.contentHandling) &&
        Objects.equals(this.timeoutInMillis, putIntegrationRequest.timeoutInMillis) &&
        Objects.equals(this.tlsConfig, putIntegrationRequest.tlsConfig);
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, httpMethod, uri, connectionType, connectionId, credentials, requestParameters, requestTemplates, passthroughBehavior, cacheNamespace, cacheKeyParameters, contentHandling, timeoutInMillis, tlsConfig);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PutIntegrationRequest {\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    httpMethod: ").append(toIndentedString(httpMethod)).append("\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    connectionType: ").append(toIndentedString(connectionType)).append("\n");
    sb.append("    connectionId: ").append(toIndentedString(connectionId)).append("\n");
    sb.append("    credentials: ").append(toIndentedString(credentials)).append("\n");
    sb.append("    requestParameters: ").append(toIndentedString(requestParameters)).append("\n");
    sb.append("    requestTemplates: ").append(toIndentedString(requestTemplates)).append("\n");
    sb.append("    passthroughBehavior: ").append(toIndentedString(passthroughBehavior)).append("\n");
    sb.append("    cacheNamespace: ").append(toIndentedString(cacheNamespace)).append("\n");
    sb.append("    cacheKeyParameters: ").append(toIndentedString(cacheKeyParameters)).append("\n");
    sb.append("    contentHandling: ").append(toIndentedString(contentHandling)).append("\n");
    sb.append("    timeoutInMillis: ").append(toIndentedString(timeoutInMillis)).append("\n");
    sb.append("    tlsConfig: ").append(toIndentedString(tlsConfig)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("type");
    openapiFields.add("httpMethod");
    openapiFields.add("uri");
    openapiFields.add("connectionType");
    openapiFields.add("connectionId");
    openapiFields.add("credentials");
    openapiFields.add("requestParameters");
    openapiFields.add("requestTemplates");
    openapiFields.add("passthroughBehavior");
    openapiFields.add("cacheNamespace");
    openapiFields.add("cacheKeyParameters");
    openapiFields.add("contentHandling");
    openapiFields.add("timeoutInMillis");
    openapiFields.add("tlsConfig");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PutIntegrationRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PutIntegrationRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PutIntegrationRequest is not found in the empty JSON string", PutIntegrationRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PutIntegrationRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PutIntegrationRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : PutIntegrationRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the required field `type`
      TypeEnum.validateJsonElement(jsonObj.get("type"));
      if ((jsonObj.get("httpMethod") != null && !jsonObj.get("httpMethod").isJsonNull()) && !jsonObj.get("httpMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `httpMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("httpMethod").toString()));
      }
      if ((jsonObj.get("uri") != null && !jsonObj.get("uri").isJsonNull()) && !jsonObj.get("uri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uri").toString()));
      }
      if ((jsonObj.get("connectionType") != null && !jsonObj.get("connectionType").isJsonNull()) && !jsonObj.get("connectionType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `connectionType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("connectionType").toString()));
      }
      // validate the optional field `connectionType`
      if (jsonObj.get("connectionType") != null && !jsonObj.get("connectionType").isJsonNull()) {
        ConnectionTypeEnum.validateJsonElement(jsonObj.get("connectionType"));
      }
      if ((jsonObj.get("connectionId") != null && !jsonObj.get("connectionId").isJsonNull()) && !jsonObj.get("connectionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `connectionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("connectionId").toString()));
      }
      if ((jsonObj.get("credentials") != null && !jsonObj.get("credentials").isJsonNull()) && !jsonObj.get("credentials").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `credentials` to be a primitive type in the JSON string but got `%s`", jsonObj.get("credentials").toString()));
      }
      if ((jsonObj.get("passthroughBehavior") != null && !jsonObj.get("passthroughBehavior").isJsonNull()) && !jsonObj.get("passthroughBehavior").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `passthroughBehavior` to be a primitive type in the JSON string but got `%s`", jsonObj.get("passthroughBehavior").toString()));
      }
      if ((jsonObj.get("cacheNamespace") != null && !jsonObj.get("cacheNamespace").isJsonNull()) && !jsonObj.get("cacheNamespace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cacheNamespace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cacheNamespace").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("cacheKeyParameters") != null && !jsonObj.get("cacheKeyParameters").isJsonNull() && !jsonObj.get("cacheKeyParameters").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `cacheKeyParameters` to be an array in the JSON string but got `%s`", jsonObj.get("cacheKeyParameters").toString()));
      }
      if ((jsonObj.get("contentHandling") != null && !jsonObj.get("contentHandling").isJsonNull()) && !jsonObj.get("contentHandling").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentHandling` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentHandling").toString()));
      }
      // validate the optional field `contentHandling`
      if (jsonObj.get("contentHandling") != null && !jsonObj.get("contentHandling").isJsonNull()) {
        ContentHandlingEnum.validateJsonElement(jsonObj.get("contentHandling"));
      }
      // validate the optional field `tlsConfig`
      if (jsonObj.get("tlsConfig") != null && !jsonObj.get("tlsConfig").isJsonNull()) {
        PutIntegrationRequestTlsConfig.validateJsonElement(jsonObj.get("tlsConfig"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PutIntegrationRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PutIntegrationRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PutIntegrationRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PutIntegrationRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<PutIntegrationRequest>() {
           @Override
           public void write(JsonWriter out, PutIntegrationRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PutIntegrationRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PutIntegrationRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PutIntegrationRequest
   * @throws IOException if the JSON string is invalid with respect to PutIntegrationRequest
   */
  public static PutIntegrationRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PutIntegrationRequest.class);
  }

  /**
   * Convert an instance of PutIntegrationRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

